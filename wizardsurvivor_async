import pygame, sys, time, asyncio, random, math

# CONSTANTS
SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 720
GAME_WIDTH = 5000
GAME_HEIGHT = 5000
EXTRAS = { "coins": {"name": "200 Coins",
                "image": "graphics/coin_large.png",
                "description": "Two hundred smackaroos!"}
            }
WEAPONS = { "standard": {"type": "bullet",
                "name": "Poison Shot",
                "movement": "facing",
                "image": "graphics/standard.png",
                "sprite": "graphics/standard_sprite.png",
                "description": "Shoots where you point, poisons enemies!  Simple as that!",
                    0: {"cooldown": 500, "damage": 1, "lifespan": 1, "speed": 5, "amount": 1},
                    1: {"cooldown": 500, "damage": 1, "lifespan": 1, "speed": 5, "amount": 2},
                    2: {"cooldown": 500, "damage": 2, "lifespan": 1, "speed": 5, "amount": 3},
                    3: {"cooldown": 500, "damage": 2, "lifespan": 1, "speed": 6, "amount": 4},
                    4: {"cooldown": 500, "damage": 3, "lifespan": 1, "speed": 6, "amount": 5},
                    5: {"cooldown": 500, "damage": 3, "lifespan": 1, "speed": 6, "amount": 6}
            },
            "circling": {"type": "bullet",
                "name": "Firespin",
                "movement": "circling",
                "image": "graphics/circling.png",
                "sprite": "graphics/standard_sprite.png",
                "description": "Does little circly thingies!",
                    0: {"cooldown": 500, "damage": 1, "lifespan": 1, "speed": 5, "amount": 1},
                    1: {"cooldown": 500, "damage": 2, "lifespan": 1, "speed": 5, "amount": 2},
                    2: {"cooldown": 500, "damage": 2, "lifespan": 1, "speed": 5, "amount": 3},
                    3: {"cooldown": 500, "damage": 3, "lifespan": 1, "speed": 5, "amount": 4},
                    4: {"cooldown": 500, "damage": 3, "lifespan": 1, "speed": 5, "amount": 5},
                    5: {"cooldown": 500, "damage": 4, "lifespan": 1, "speed": 5, "amount": 6}
            },
            "tracking": {"type": "bullet",
                "name": "Emerett's Eye",
                "movement": "tracking",
                "image": "graphics/tracking.png",
                "sprite": "graphics/standard_sprite.png",
                "description": "Follows those fuckers...",
                    0: {"cooldown": 500, "damage": 2, "lifespan": 1, "speed": 2, "amount": 1},
                    1: {"cooldown": 500, "damage": 3, "lifespan": 1, "speed": 2, "amount": 2},
                    2: {"cooldown": 500, "damage": 3, "lifespan": 1, "speed": 2, "amount": 2},
                    3: {"cooldown": 500, "damage": 4, "lifespan": 1, "speed": 3, "amount": 3},
                    4: {"cooldown": 500, "damage": 4, "lifespan": 1, "speed": 3, "amount": 3},
                    5: {"cooldown": 500, "damage": 5, "lifespan": 1, "speed": 4, "amount": 4}
            },
            "random": {"type": "bullet",
                "name": "Sticky Mess",
                "movement": "random",
                "image": "graphics/random.png",
                "sprite": "graphics/standard_sprite.png",
                "description": "Goes all willy-nilly, but there's lots!",
                    0: {"cooldown": 1000, "damage": 1, "lifespan": 1, "speed": 5, "amount": 5},
                    1: {"cooldown": 1000, "damage": 2, "lifespan": 1, "speed": 5, "amount": 5},
                    2: {"cooldown": 1000, "damage": 2, "lifespan": 1, "speed": 5, "amount": 6},
                    3: {"cooldown": 1000, "damage": 3, "lifespan": 1, "speed": 6, "amount": 6},
                    4: {"cooldown": 1000, "damage": 3, "lifespan": 1, "speed": 6, "amount": 7},
                    5: {"cooldown": 1000, "damage": 4, "lifespan": 1, "speed": 6, "amount": 8}
                }
            }
PASSIVES = {"explosive": {"type": "passive",
                "name": "Elixir of Chaos",
                "image": "graphics/explosive.png",
                "description": "Grants explosive to all projectile weapons!",
                    0: {"explosive": True, "explosion_radius": 2},
                    1: {"explosive": True, "explosion_radius": 3},
                    2: {"explosive": True, "explosion_radius": 4},
                    3: {"explosive": True, "explosion_radius": 5},
                    4: {"explosive": True, "explosion_radius": 7},
                    5: {"explosive": True, "explosion_radius": 10},
                },
            "speedup": {"type": "passive",
                "name": "Elixir of Speed",
                "image": "graphics/speedup.png",
                "description": "Run faster, jump higher!",
                    0: {"player_speed": 1.1},
                    1: {"player_speed": 1.2},
                    2: {"player_speed": 1.3},
                    3: {"player_speed": 1.4},
                    4: {"player_speed": 1.5},
                    5: {"player_speed": 1.6},
                },
            "lifespan": {"type": "passive",
                "name": "Elixir of Stone",
                "image": "graphics/penetrate.png",
                "description": "All projectiles get more penetrative...",
                    0: {"projectile_lifespan": 1},
                    1: {"projectile_lifespan": 1},
                    2: {"projectile_lifespan": 2},
                    3: {"projectile_lifespan": 2},
                    4: {"projectile_lifespan": 3},
                    5: {"projectile_lifespan": 4},
                }
            }
ENEMIES = {"Drone":    {"type": "standard",
                        "movement": "follow",
                        "damage": 5,
                        "health": 5,
                        "speed": 1},
           "Worker":   {"type": "fast",
                        "movement": "follow",
                        "damage": 3,
                        "health": 2,
                        "speed": 2},
           "Tank":     {"type": "tank",
                        "movement": "follow",
                        "damage": 4,
                        "health": 10,
                        "speed": 1},
           }
PICKUPS = {"nothing": {"image": None,
                       "weight": 40,
                       "magnet": False,
                       "value": "0"},
           "heart": {"image": "graphics/heart.png",
                     "weight": 5,
                     "magnet": False,
                     "value": 10},
           "coin": {"image": "graphics/coin.png",
                    "weight": 25,
                    "magnet": True,
                    "value": 10},
           "experience": {"image": "graphics/exp.png",
                          "weight": 30,
                          "magnet": True,
                          "value": 15}
           }
MAPS = {"1": {"timeout": 5,
                "background": 'graphics/ground.png',
                "bgcolor": '#ffffff',
                "enemies": [ENEMIES["Drone"], 
                            ENEMIES["Worker"], 
                            ENEMIES["Tank"]],
                "bosses": [],
                "waves": [50, 50, 100, 100],
                "width": 2000,
                "height": 2000},
        "2": {"timeout": 15,
            "background": '',
            "enemies": [ENEMIES["Drone"], 
                        ENEMIES["Worker"], 
                        ENEMIES["Tank"]],
            "bosses": [],
            "waves": [50, 50, 100, 100],
            "width": 2000,
            "height": 2000}
          }
CHARACTERS = {"Wizard Bob": 
                {"image": "graphics/player.png",
                 "health": 100,
                 "health_regen": 0,
                 "armor": 1,
                 "speed": 2,
                 "damage": 1,
                 "extra_projectiles": 0,
                 },}

class CameraGroup(pygame.sprite.Group):
    def __init__(self, background):
        super().__init__()
        self.enemy_group = pygame.sprite.Group()
        self.projectile_group = pygame.sprite.Group()
        self.pickup_group = pygame.sprite.Group()
        self.display_surf = pygame.display.get_surface()
        
        # Camera offset
        self.offset = pygame.math.Vector2()
        self.half_w = self.display_surf.get_size()[0] // 2
        self.half_h = self.display_surf.get_size()[1] // 2
        
        # Ground
        self.ground_surf = pygame.image.load(background).convert_alpha()
        self.ground_rect = self.ground_surf.get_rect(topleft = (0,0))
    
    def set_player(self, player):
        self.player = player
        
    def get_relative(self, target):
        self.offset.x = target.rect.centerx - self.half_w
        self.offset.y = target.rect.centery - self.half_h
        return self.offset
    
    def custom_draw(self, target):
        self.offset.x = target.rect.centerx - self.half_w
        self.offset.y = target.rect.centery - self.half_h
        self.display_surf.blit(self.ground_surf, self.ground_rect.topleft - self.offset) # Ground
        for sprite in sorted(self.pickup_group.sprites(), key = lambda sprite: sprite.rect.centery):
            self.display_surf.blit(sprite.image, sprite.rect.topleft - self.offset) # Pickups
            
        for sprite in sorted(self.enemy_group.sprites(), key = lambda sprite: sprite.rect.centery):
            self.display_surf.blit(sprite.image, sprite.rect.topleft - self.offset) # Enemies
            
        for sprite in sorted(self.projectile_group.sprites(), key = lambda sprite: sprite.rect.centery):
            self.display_surf.blit(sprite.image, sprite.rect.topleft - self.offset) # Projectiles
            
        self.display_surf.blit(self.player.image, self.player.rect.topleft - self.offset) # Player

class Pickup(pygame.sprite.Sprite):
    def __init__(self, position, groups, type, item):
        super().__init__(groups)
        self.image = pygame.image.load(item["image"]).convert_alpha()
        self.rect = self.image.get_rect(center = position)
        self.type = type
        self.speed = 1
        self.item = item
        self.magnet = item["magnet"]
        self.moving = False
        
    def update(self, player, enemy_group):
        if self.moving:
            self.move(player)
        self.check_collision(player)
    
    def move(self, player):
        delta_x = player.rect.centerx - self.rect.centerx
        delta_y = player.rect.centery - self.rect.centery
        distance = math.hypot(delta_x, delta_y)
        if distance > 0:
            self.dir = (delta_x / distance, delta_y / distance)

        self.speed *= 1.02
        new_x = self.rect.x + self.dir[0] * self.speed
        new_y = self.rect.y + self.dir[1] * self.speed
        self.rect.x = new_x
        self.rect.y = new_y
    
    def check_collision(self, player):
        if pygame.sprite.collide_rect(self, player):
            player.collect(self.type, self.item)
            self.kill()
            
class Enemy(pygame.sprite.Sprite):
    def __init__(self, position, groups, template, current_map):
        super().__init__(groups)
        self.current_map = current_map
        self.acceleration = 0.1
        self.friction = 0.05
        self.velocity = pygame.math.Vector2(0, 0)
        self.max_speed = template["speed"]
        self.image = pygame.image.load('graphics/enemy.png').convert_alpha()
        self.rect = self.image.get_rect(center = position)
        self.dir = (0,0)
        self.health = template["health"]
        self.damage = template["damage"]
        self.is_damaged = False
        self.flash_end_time = 0
        self.flash_duration = 100
        self.flash_color = (255, 255, 255)
        self.original_image = self.image.copy()
    
    def update(self, player, enemy_group):
        if pygame.time.get_ticks() < self.flash_end_time:
            flash_surface = pygame.Surface(self.rect.size).convert_alpha()
            flash_surface.fill(self.flash_color)
            self.image.blit(flash_surface, (0, 0), special_flags=pygame.BLEND_RGB_ADD)
        else:
            if self.is_damaged == True:
                self.image.blit(self.original_image, (0,0))
                self.is_damaged = False
            self.move(player, enemy_group)
            self.check_collision(player)
        
    def move(self, player, enemy_group):
        delta_x = player.rect.centerx - self.rect.centerx
        delta_y = player.rect.centery - self.rect.centery
        distance = math.hypot(delta_x, delta_y)
        if distance > 0:
            self.dir = (delta_x / distance, delta_y / distance)

        new_x = self.rect.x + self.dir[0] * self.max_speed
        new_y = self.rect.y + self.dir[1] * self.max_speed
        if self.dir != (0, 0):
            self.velocity += pygame.math.Vector2(self.dir[0] * self.max_speed, self.dir[1] * self.max_speed) * self.acceleration
        else:
            friction_force = -self.velocity * self.friction
            self.velocity += friction_force

        if self.velocity.length() > self.max_speed:
            self.velocity.scale_to_length(self.max_speed)

        collision_rect = self.rect.inflate(-self.rect.width // 2, -self.rect.height // 2)
        collision_rect.topleft = (new_x + self.rect.width // 4, new_y + self.rect.height // 4)
        for enemy in enemy_group:
            if enemy != self and collision_rect.colliderect(enemy.rect):
                delta_x = self.rect.centerx - enemy.rect.centerx
                delta_y = self.rect.centery - enemy.rect.centery
                distance = math.hypot(delta_x, delta_y)
                if distance > 0:
                    away_dir = (delta_x / distance, delta_y / distance)
                    new_x += away_dir[0]
                    new_y += away_dir[1]

        self.rect.x = new_x
        self.rect.y = new_y
    
    def check_collision(self, player):
        if pygame.sprite.collide_rect(self, player):
            player.damaged(self.damage)
        
    def damaged(self, damage):
        self.flash_end_time = pygame.time.get_ticks() + self.flash_duration
        self.is_damaged = True
        self.health -= damage
        if self.health <= 0:
            self.current_map.spawn_pickup(self.rect.center)
            self.kill()
    
class Bullet(pygame.sprite.Sprite):
    def __init__(self, position, groups, direction, weapon, level, modifiers, radius = None,):
        super().__init__(groups)
        self.image = pygame.image.load('graphics/bullet.png').convert_alpha()
        self.rect = self.image.get_rect(center = position)
        self.type = weapon["movement"]
        self.dir = direction
        self.radius = radius
        self.explosive = modifiers["explosive"]
        self.explosion_radius = modifiers["explosion_radius"] + modifiers["power_radius"]
        self.projectile_speed = weapon[level]["speed"] * modifiers["projectile_speed_mult"]
        self.damage = (weapon[level]["damage"] + modifiers["damage"]) * modifiers["damage_mult"]
        self.lifespan = weapon[level]["lifespan"] + modifiers["projectile_lifespan"]
        self.target = None
        self.angle = 0

    def update(self, player, enemy_group):
        self.move(player, enemy_group)
        if (abs(self.rect.centerx - player.rect.centerx) > SCREEN_WIDTH or abs(self.rect.centery - player.rect.centery) > SCREEN_HEIGHT):
            self.kill()
        
        collision = pygame.sprite.spritecollideany(self, enemy_group)
        if collision is not None:
            self.collide(collision)
        
    def move(self, player, enemy_group):
        if self.type == "circling":
            self.angle += self.projectile_speed
            if self.angle >= 360:
                self.angle -= 360
            angle = math.radians(self.angle)
            self.rect.x = player.rect.centerx + self.radius * math.cos(angle)
            self.rect.y = player.rect.centery + self.radius * math.sin(angle)
            self.radius += 1
            
        elif self.type == "tracking":
            if self.target is None:
                nearest_enemy = None
                min_distance = float('inf')
                for enemy in enemy_group:
                    distance = math.hypot(self.rect.centerx - enemy.rect.centerx, self.rect.centery - enemy.rect.centery)
                    if distance < min_distance:
                        nearest_enemy = enemy
                        min_distance = distance

                if nearest_enemy is not None:
                    # Calculate the direction to the nearest enemy
                    delta_x = nearest_enemy.rect.centerx - self.rect.centerx
                    delta_y = nearest_enemy.rect.centery - self.rect.centery
                    distance = math.hypot(delta_x, delta_y)
                    if distance > 0:
                        self.dir = (delta_x / distance, delta_y / distance)

                self.rect.x = self.rect.x + self.dir[0] * self.projectile_speed
                self.rect.y = self.rect.y + self.dir[1] * self.projectile_speed
        else:
            self.rect.x = self.rect.x + self.dir[0] * self.projectile_speed
            self.rect.y = self.rect.y + self.dir[1] * self.projectile_speed
        
    def collide(self, target):
        target.damaged(self.damage)
        if self.lifespan is not None:
            self.lifespan -= 1
            if self.lifespan <= 0:
                self.kill()

class Player(pygame.sprite.Sprite):
    def __init__(self, position, group, weapon_name, current_map):
        super().__init__(group)
        self.current_map = current_map
        self.weapons = [[weapon_name, 0]]
        self.passives = []
        self.modifiers = {"damage": 0,
                          "explosive": False,
                          "explosion_radius": 0,
                          "pickup_radius": 0,
                          "power_radius": 0,
                          "projectile_lifespan": 0,
                          "extra_projectiles": 0,
                          "health_regen": 0,
                          "armor": 0,
                          "luck": 0,
                          "exp_mult": 1,
                          "heal_mult": 1,
                          "gold_mult": 1,
                          "speed_mult": 1,
                          "radius_mult": 1,
                          "damage_mult": 1,
                          "cooldown_mult": 1,
                          "duration_mult": 1,
                          "invincibility_mult": 1,
                          "projectile_speed_mult": 1,
                          }
        self.image = pygame.image.load('graphics/player.png').convert_alpha()
        self.rect = self.image.get_rect(topleft = position)
        self.pickup_circle = self.rect
        self.invincible = False
        self.friction = 0.1
        self.max_speed = 2.0
        self.acceleration = 0.2
        self.velocity = pygame.math.Vector2(0, 0)
        self.animating = False
        self.animation = 0
        self.frame = 0
        self.level = 0
        self.lives = 1
        self.health = 100
        self.health_regen = 0
        self.damage = 1
        self.armor = 1
        self.money = 0
        self.exp = 0
        self.exp_curve = 1.2
        self.exp_to_level = 15
        self.extra_projectiles = 0
        self.max_health = self.health
        self.flash_color = pygame.Color(255,0,0)
        self.original_image = self.image.copy()
    
    def move(self):
        max_speed = self.max_speed * self.modifiers["speed_mult"]
        keys = pygame.key.get_pressed()
        if keys[pygame.K_UP] and not keys[pygame.K_DOWN]:
            self.velocity.y = max(self.velocity.y - self.acceleration, -max_speed)
        elif keys[pygame.K_DOWN] and not keys[pygame.K_UP]:
            self.velocity.y = min(self.velocity.y + self.acceleration, max_speed)
        else:
            self.velocity.y *= (1 - self.friction)

        if keys[pygame.K_LEFT] and not keys[pygame.K_RIGHT]:
            self.velocity.x = max(self.velocity.x - self.acceleration, -max_speed)
        elif keys[pygame.K_RIGHT] and not keys[pygame.K_LEFT]:
            self.velocity.x = min(self.velocity.x + self.acceleration, max_speed)
        else:
            self.velocity.x *= (1 - self.friction)
            
        self.rect.center += self.velocity
            
    def shoot(self, weapon, level, groups):
        for i in range(0, weapon[level]["amount"]):
            radius = None
            if weapon["movement"] == "random":
                distance = (random.uniform(-1, 1), random.uniform(-1, 1))
                position = (self.rect.x + self.rect.width / 2, self.rect.y + self.rect.height / 2)
                
            elif weapon["movement"] == "facing":
                mouse_pos = pygame.mouse.get_pos()
                distance = (mouse_pos[0] - SCREEN_WIDTH // 2, mouse_pos[1] - SCREEN_HEIGHT // 2)
                position = (self.rect.x + self.rect.width / 2, self.rect.y + self.rect.height / 2)

            elif weapon["movement"] == "circling":
                radius = 50
                distance = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
                position = ((self.rect.x + self.rect.width / 2, self.rect.y + self.rect.height / 2))
            
            elif weapon["movement"] == "tracking":
                distance = (random.uniform(-1, 1), random.uniform(-1, 1))
                position = (self.rect.x + self.rect.width / 2, self.rect.y + self.rect.height / 2)
            
            normal = math.sqrt(distance[0] ** 2 + distance[1] ** 2)
            direction = [distance[0] / normal, distance[1] / normal]
            Bullet(position, groups, (direction[0], direction[1]), weapon, level, self.modifiers, radius)

    def level_up(self):
        self.level += 1
        self.exp = 0
        self.exp_to_level *= self.exp_curve
        set_gamestate("levelup")
    
    def collect(self, type, item):
        if type == "coin":
            self.money += math.ceil(item["value"] * self.modifiers["gold_mult"])
            
        elif type == "heart":
            self.heal(item["value"])
            
        elif type == "experience":
            self.exp += item["value"] * self.modifiers["exp_mult"]
            if self.exp >= self.exp_to_level:
                self.level_up()

    def heal(self, amount):
        full_amount = math.ceil(amount * self.modifiers["heal_mult"])
        self.health = self.max_health if self.health + full_amount >= self.max_health else self.health + full_amount

    def damaged(self, damage):
        if not self.invincible:
            self.health -= max(damage - (self.armor + self.modifiers["armor"]), 0)
            invincibility_time = 500 * self.modifiers["invincibility_mult"]
            self.animating = True
            self.animation = 10
            self.invincible = True
            
        if self.health <= 0:
            self.lives -= 1

        if self.lives == 0:
            self.current_map.failed()
        
    def damageable(self):
        self.invincible = False

    def update(self, player, enemy_group):
        if self.animating:
            if self.frame > self.animation:
                self.frame = 0
                self.animating = False
                self.image.blit(self.original_image, (0,0))
            else:
                self.frame += 1
                fade_factor = 1 - (self.frame/10)
                red_component = int(self.flash_color.r * fade_factor)
                flash_color = pygame.Color(red_component, self.flash_color.g, self.flash_color.b, self.flash_color.a)
                flash_surface = pygame.Surface(self.rect.size, pygame.SRCALPHA)
                flash_surface.fill(flash_color)
                self.image.blit(flash_surface, (0, 0), special_flags=pygame.BLEND_RGBA_ADD)
                
            
        self.move()

class CurrentMap():
    def __init__(self, current_map, difficulty):
        self.running = True
        self.finished_upgrades = []
        self.available_upgrades = list(WEAPONS.keys()) + list(PASSIVES.keys())
        self.timeout = current_map["timeout"] * 60
        self.enemies = current_map["enemies"]
        self.bosses = current_map["bosses"]
        self.ground = current_map["background"]
        self.ground_fill = current_map["bgcolor"]
        self.difficulty = difficulty
        self.width = current_map["width"]
        self.height = current_map["height"]
        self.bar_width = 100
        self.bar_height = 10
        self.title_font = pygame.font.Font(None, 48)
        self.stats_font = pygame.font.Font(None, 16)
        pygame.time.set_timer(pygame.USEREVENT, 1000)
        self.choices = random.sample(self.available_upgrades, 5)
        self.load_map()
        self.set_powers()
    
    # ------------------------ SPAWNING ------------------------
    def spawn_enemies(self, enemy, amount):
        for i in range(0, amount):
            Enemy(self.random_point_on_circle(self.player.rect.centerx,
                                              self.player.rect.centery,
                                              SCREEN_WIDTH // 2),
                  [self.camera_group, self.camera_group.enemy_group], enemy, self)
    
    def spawn_boss(self, boss):
        pass
    
    def spawn_pickup(self, pos):
        random_pickup = random.choices(list(PICKUPS.keys()), weights=[pickup["weight"] for pickup in PICKUPS.values()], k = 1)
        if random_pickup[0] != "nothing":
            Pickup(pos, [self.camera_group, self.camera_group.pickup_group], random_pickup[0], PICKUPS[random_pickup[0]])

    # ------------------------ MISC ------------------------
    def level_up(self, choice):
        if choice in list(EXTRAS.keys()):
            self.player.money += 200
            
        for weapon in self.player.weapons:
            if choice == weapon[0]:
                weapon[1] += 1
                if weapon[1] >= 5:
                    self.available_upgrades = [key for key in self.available_upgrades if key != choice]
                    if len(self.available_upgrades) < 3:
                        self.available_upgrades.append("Coins")
                    self.finished_upgrades.append(choice)
                break

        for passive in self.player.passives:
            if choice == passive[0]:
                passive[1] += 1
                if passive[1] >= 5:
                    self.available_upgrades = [key for key in self.available_upgrades if key != choice]
                    if len(self.available_upgrades) < 3:
                        self.available_upgrades.append("Coins")
                    self.finished_upgrades.append(choice)
                break
            
        if choice in WEAPONS.keys():
            self.player.weapons.append([choice, 0])
        else:
            self.player.passives.append([choice, 0])
        
        self.choices = random.sample(current_map.available_upgrades, 5)
        self.set_powers()
    
    def set_powers(self):
        i = 0
        for weapon in self.player.weapons:
            pygame.time.set_timer(100 + i, WEAPONS[weapon[0]][weapon[1]]["cooldown"])
            i += 1
        for passive in self.player.passives:
            for key, value in PASSIVES[passive[0]][passive[1]].items():
                self.player.modifiers[key] = value
        pygame.time.set_timer(98, 5000)

    def load_map(self):
        self.camera_group = CameraGroup(self.ground)
        self.player = Player((self.width // 2, self.height // 2), self.camera_group, "standard", self)
        self.camera_group.set_player(self.player)
    
    def random_point_on_circle(self, center_x, center_y, radius):
        angle = random.uniform(0, 2 * math.pi)
        x = center_x + radius * math.cos(angle)
        y = center_y + radius * math.sin(angle)
        return (x, y)
    
    def draw_text(self, surface, text, font, color, rect, max_width=None):
        words = text.split(' ')
        space_width, _ = font.size(' ')

        lines = []
        current_line = []
        current_width = 0

        for word in words:
            word_width, word_height = font.size(word)

            if max_width and current_width + word_width > max_width:
                lines.append(' '.join(current_line))
                current_line = [word]
                current_width = word_width + space_width
            else:
                current_line.append(word)
                current_width += word_width + space_width

        lines.append(' '.join(current_line))

        y = rect.centery - (len(lines) - 1) * word_height // 2

        for line in lines:
            text_surface = font.render(line, True, color)
            text_rect = text_surface.get_rect(center=(rect.centerx, y))
            surface.blit(text_surface, text_rect)
            y += word_height
            
    # ------------------------ UI ------------------------
    def display_box(self, x, y, width, height, title, image_path, second_title, text):
        box_surface = pygame.Surface((width, height), pygame.SRCALPHA)
        background_image = pygame.image.load("graphics/upgrade_bg.png").convert_alpha()
        box_surface.blit(background_image, (0, 0))
        image = pygame.image.load(image_path).convert_alpha()
        image_rect = image.get_rect(center=(width // 2, height // 2 - 22))
        box_surface.blit(image, image_rect)
        font_title = pygame.font.Font(None, 22)
        font_text = pygame.font.Font(None, 16)
        title_text = font_title.render(title, True, (0, 0, 0))
        title_rect = title_text.get_rect(center=(width // 2, 13))
        second_title_text = font_title.render(second_title, True, (0, 0, 0))
        second_title_rect = second_title_text.get_rect(center=(width // 2, 33))
        text_rect = pygame.Rect(0, 0, width, height + 165)
        self.draw_text(box_surface, text, font_text, (255, 255, 255), text_rect, max_width=text_rect.width - 67)
        box_surface.blit(title_text, title_rect)
        box_surface.blit(second_title_text, second_title_rect)
        screen.blit(box_surface, (x, y))
        
    def levelup_ui(self):
        choices = self.choices
        transparent_bg = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        pygame.draw.rect(transparent_bg, (0, 0, 0, 128), (0, 0, SCREEN_WIDTH, SCREEN_HEIGHT))
        screen.blit(transparent_bg, (0,0))
        i = 0
        for choice in choices:
            level = "NEW"
            for weapon in self.player.weapons:
                if choice == weapon[0]:
                    level = f'Level {weapon[1] + 1}'
            for passive in self.player.passives:
                if choice == passive[0]:
                    level = f'Level {passive[1] + 1}'
                    
            if choice in WEAPONS.keys():
                item = WEAPONS[choice]
            elif choice in PASSIVES.keys():
                item = PASSIVES[choice]
            else:
                item = EXTRAS[choice]
                
            self.display_box(40 + (250 * i), 100, 200, 300, level, item["image"], item["name"], item["description"])
            i += 1
    
    def pause_ui(self):
        transparent_bg = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        pygame.draw.rect(transparent_bg, (0, 0, 0, 128), (0, 0, SCREEN_WIDTH, SCREEN_HEIGHT))
        screen.blit(transparent_bg, (0,0))

    def map_ui(self):
        # Title and text
        countdown = self.title_font.render(f'{max(0, self.timeout // 60)}:{str(self.timeout % 60).zfill(2)}', True, (255, 255, 255))
        countdown_rect = countdown.get_rect(center=(SCREEN_WIDTH // 2, 20))
        screen.blit(countdown, countdown_rect)
        experience = self.stats_font.render(f'Level: {self.player.level}', True, (255, 255, 255))
        experience_rect = experience.get_rect(topleft=(10, SCREEN_HEIGHT - 40))
        screen.blit(experience, experience_rect)
        money = self.stats_font.render(f'Money: {self.player.money}', True, (255, 255, 255))
        money_rect = money.get_rect(topleft=(10, SCREEN_HEIGHT - 20))
        screen.blit(money, money_rect)
        
        # Health bar
        health_ratio = self.player.health / self.player.max_health
        health_bar_x = self.player.rect.centerx - self.bar_width // 2 - self.camera_group.offset.x
        health_bar_y = self.player.rect.y - 30 - self.camera_group.offset.y
        transparent_bg = pygame.Surface((self.bar_width, self.bar_height), pygame.SRCALPHA)
        pygame.draw.rect(transparent_bg, (0, 0, 0, 64), (0, 0, self.bar_width, self.bar_height))
        screen.blit(transparent_bg, (health_bar_x, health_bar_y))
        pygame.draw.rect(screen, (255, 0, 0), (health_bar_x, health_bar_y, self.bar_width * health_ratio, self.bar_height))

        # Experience bar
        experience_ratio = self.player.exp / self.player.exp_to_level if self.player.exp < self.player.exp_to_level else 1
        experience_bar_x = self.player.rect.centerx - self.bar_width // 2 - self.camera_group.offset.x
        experience_bar_y = self.player.rect.y - 20 - self.camera_group.offset.y
        transparent_bg = pygame.Surface((self.bar_width, self.bar_height // 2), pygame.SRCALPHA)
        pygame.draw.rect(transparent_bg, (0, 0, 0, 64), (0, 0, self.bar_width, self.bar_height // 2))
        screen.blit(transparent_bg, (experience_bar_x, experience_bar_y))
        pygame.draw.rect(screen, (0, 255, 0), (experience_bar_x, experience_bar_y, self.bar_width * experience_ratio, self.bar_height // 2))
    
    def failed(self):
        pass
    
pygame.init()
event_handler = ...
drawables = [...]
game_state = "gameplay"
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT),flags=pygame.SCALED, vsync=1)
current_map = CurrentMap(MAPS["1"], 1)

def set_gamestate(action):
    global game_state
    if action == "toggle":
        if game_state == "paused":
            game_state = "gameplay"
        else:
            game_state = "paused"
    else:
        game_state = action
    
async def game_loop(framerate_limit=math.inf):
    loop = asyncio.get_event_loop()
    next_frame_target = 0.0
    limit_frame_duration = (1.0 / framerate_limit)

    while True:
        if limit_frame_duration:
            this_frame = time.time()
            delay = next_frame_target - this_frame
            if delay > 0:
                await asyncio.sleep(delay)
            next_frame_target = this_frame + limit_frame_duration
            
        if game_state in ("gameplay", "paused", "levelup"):
            screen.fill(current_map.ground_fill)
            current_map.camera_group.custom_draw(current_map.player)
            if game_state == "gameplay":
                current_map.camera_group.update(current_map.player, current_map.camera_group.enemy_group)
            
            current_map.map_ui()
            if game_state in ("paused", "levelup"):
                current_map.pause_ui()
                if game_state == "levelup":
                    current_map.levelup_ui()
                
        events_to_handle = list(pygame.event.get())
        events_handled = loop.create_task(handle_events(events_to_handle))
        await loop.run_in_executor(None, pygame.display.update)
        await events_handled

async def handle_events(events_to_handle):
    box1_rect = pygame.Rect(40, 100, 200, 300)
    box2_rect = pygame.Rect(290, 100, 200, 300)
    box3_rect = pygame.Rect(540, 100, 200, 300)
    box4_rect = pygame.Rect(790, 100, 200, 300)
    box5_rect = pygame.Rect(1040, 100, 200, 300)
    for event in events_to_handle:
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

        if current_map is not None:
            if event.type == pygame.USEREVENT:
                current_map.timeout -= 1
                if len(current_map.camera_group.enemy_group) <= 1:
                    current_map.spawn_enemies(current_map.enemies[0], random.randrange(1, 5))

            if event.type == 98:
                current_map.player.heal(current_map.player.modifiers["health_regen"])

            if event.type == 99:
                current_map.player.damageable()
                
            if event.type in range(100, 100 + len(WEAPONS) - 1):
                if WEAPONS[current_map.player.weapons[event.type - 100][0]]["type"] == "bullet":
                    current_map.player.shoot(WEAPONS[current_map.player.weapons[event.type - 100][0]], 
                                             current_map.player.weapons[event.type - 100][1], 
                                             [current_map.camera_group, current_map.camera_group.projectile_group])

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_0:
                    set_gamestate("toggle")

                if event.key == pygame.K_1:
                    for pickup in current_map.camera_group.pickup_group:
                        if pickup.magnet:
                            pickup.moving = True
            
            if event.type == pygame.MOUSEBUTTONDOWN and game_state == "levelup":
                mouse_x, mouse_y = pygame.mouse.get_pos()
                if box1_rect.collidepoint(mouse_x, mouse_y):
                    current_map.level_up(current_map.choices[0])
                elif box2_rect.collidepoint(mouse_x, mouse_y):
                    current_map.level_up(current_map.choices[1]) 
                elif box3_rect.collidepoint(mouse_x, mouse_y):
                    current_map.level_up(current_map.choices[2])
                elif box4_rect.collidepoint(mouse_x, mouse_y):
                    current_map.level_up(current_map.choices[3])
                elif box5_rect.collidepoint(mouse_x, mouse_y):
                    current_map.level_up(current_map.choices[4])
                else:
                    continue

asyncio.run(game_loop(120))